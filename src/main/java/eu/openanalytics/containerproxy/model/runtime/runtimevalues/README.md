# Runtime values

This README describes the (design) ideas behind the runtime-values usystem.

## Goals

 - it should be possible to add arbitrary values to a `Proxy` instance at runtime (hence it's name). This means that the
   values are only known when an application is effectively started (and thus not when the specs are processed).
 - it should be possible for ShinyProxy (or any frontend for ContainerProxy) to add new types of runtime-values.
 - the values should be persisted when used in combination with App Recovery or High Availability. This implies that
   the values must be stored as labels (or annotations) on the app containers.
 - it should be relatively easy to access these values using SpEL.
 - the values may not contain SpEL expression.
 - values provided by the user (using `container-env`, `labels` or kubernetes-pod-patches) should have precedence on the
   values generated by ShinyProxy. This ensures the user can always control the value of these labels and environment
   variables. E.g. the user might want to remove sensitive values. Of course, if the user modifies these values,
   App Recovery isn't guaranteed to work.

## Implementation

The three most important classes of the implementation are:
   - `RuntimeValueKey` this is an abstract class and contains all metadata for a given runtime-value. Since all metadata
      is stored in a class, we benefit from static typing. Furthermore, all metadata is stored at one (and only one)
      location. Each implementation of the class should have a private constructor and a `public static` field
      called `inst` containing the singleton of this key.
   - `RuntimeValue` this a POJO containing a `String` value and a `RuntimeValueKey` key. This class is used to effectively
      store the values
   - `RuntimeValueKeyRegistry` this is a (non-static) class only containing static members and fields. The idea of the
      class is to keep track of the `RuntimeValueKey` instances. Therefore, every instance of `RuntimeValueKey` must be
      registered in this registry. Such a registry is needed for the App Recovery feature. When recovering an app,
      ShinyProxy must be able to restore the runtime-values as well. Therefore, it needs to know about all possible keys,
      in order to know at which labels and or annotations it must look. This could also have been implemented using reflection
      (possible using annotations) or using Spring Beans. However, the advantage of the `RuntimeValueKeyRegistry` is
      that is a simple solution which doesn't rely on reflection.

## SpEL

The runtime-values can be used as follows in SpEL expressions:r

```yaml
  - id: 01_hello_advanced_runtime_labels # 12
    container-specs:
      - image: "openanalytics/shinyproxy-demo"
        cmd: [ "R", "-e", "shinyproxy::run_01_hello()" ]
        port-mapping:
          default: 3838
        env:
          TEST_PROXY_ID: "#{proxy.getRuntimeValue('SHINYPROXY_PROXY_ID')}"
          SHINYPROXY_USERNAME: "abc_xyz"
          TEST_INSTANCE_ID: "#{proxy.getRuntimeValue('SHINYPROXY_INSTANCE')}"
        labels:
          custom_username_label: "#{proxy.getRuntimeValue('SHINYPROXY_USERNAME')}"
    kubernetes-pod-patches: |
     - op: add
       path: /spec/containers/0/env/-
       value:
         name: SHINYPROXY_USERNAME_PATCH
         value: "#{proxy.getRuntimeValue('SHINYPROXY_USERNAME')}"
     - op: add
       path: /metadata/labels/custom_label_patch_instance
       value: "#{proxy.getRuntimeValue('SHINYPROXY_INSTANCE')}"
```

The order in which values for environment variables and labels are computed is:

- the value of the runtime-values
- the value specified in the container-spec
- the value specified in the `kubernetes-pod-patches`

Values specified in the container-spec override value specified by the runtime-values. E.g. the above specification will
only have a single `SHINYPROXY_USERNAME` environment variable. However, this does not hold for values specified in the
`kubernetes-pod-patches` field. The reason is that the user is free to do whatever they want in the `kubernetes-pod-patches`
field and we cannot prevent duplicate values in a good way here. If you want to override environment variables using
`kubernetes-pod-patches` you must replace the whole container-env:

```yaml
  - id: 01_hello_advanced_runtime_labels # 12
    container-specs:
      - image: "openanalytics/shinyproxy-demo"
        cmd: [ "R", "-e", "shinyproxy::run_01_hello()" ]
        port-mapping:
          default: 3838
        env:
          TEST_PROXY_ID: "#{proxy.getRuntimeValue('SHINYPROXY_PROXY_ID')}"
    kubernetes-pod-patches: |
     - op: replace
       path: /spec/containers/0/env
       value:
         name: SHINYPROXY_USERNAME_PATCH
         value: "my-overriden-username"
```

This app will contain a single environment variable `SHINYPROXY_USERNAME`, containing `my-overriden-username`.

## Differences with field abc of class xyz

The `ContainerSpec` class already contains fields for `env`, `labels` and `settings`, so one may wonder why we need the
runtime-values system. The reason is that, all these fields are part of the *specification* of an app and therefore
modifying a value in these fields is applied to **all** instances of the app. Therefore, we cannot have values that
are determined on runtime (i.e. when the app is started). This also holds for the `settings` and `runtimeSettingSpecs` fields of `ProxySpec`.

Finally, the `Container` class (which is part of the runtime of an app) contains the `parameters` field. Again you can
wonder why this cannot be used. To start, this field can store arbitrary objects, whereas the runtime-values stores only strings.
Arbitrary objects cannot be persisted to labels or annotations without causing lots of overhead. In fact the parameters
are only used for caching objects that do not need to be persisted. Finally, this field is part of the `Container` class
and not of the `Proxy` class, therefore we would have to add these values to every single `Container` of a `Proxy`.
     registered in this registry. Such a registry is needed for the App Recovery feature. When recovering an app,
     ShinyProxy must be able to restore the runtime-values as well. Therefore, it needs to know about all possible keys,
     in order to know at which labels and or annotations it must look. This could also have been implemented using reflection
     (possible using annotations) or using Spring Beans. However, the advantage of the `RuntimeValueKeyRegistry` is
     that is a simpler solution which doesn't rely on reflection.

## SpEL

The runtime-values can be used as follows in SpEL expressions:


